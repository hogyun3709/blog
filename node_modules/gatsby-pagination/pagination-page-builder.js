"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _constants = require("./constants");

var _constants2 = _interopRequireDefault(_constants);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Creates the subsets of node based on limit
 * @param {Array.<Object>} edges - the list of edges/nodes
 * @param {number} limit - the limit of nodes per subset
 * @return {{Array.<Array.<Object>>}} - subsets of edges
 * @private
 */
var createEdgeSubsets = function createEdgeSubsets(edges, limit) {
  return edges.map(function (edge, index) {
    return index % limit === 0 ? edges.slice(index, index + limit) : null;
  }).filter(function (item) {
    return item;
  });
};

/**
 * @param index {number} page index
 * @return {boolean} - if page have a previous page.
 * @private
 */
var hasPrevPage = function hasPrevPage(index) {
  return index - 1 >= 0;
};

/**
 * @param index {number} page index
 * @param pages {number} number of pages
 * @return {boolean} - if page have a next page.
 * @private
 */
var hasNextPage = function hasNextPage(index, pages) {
  return index + 1 < pages.length;
};

/**
 * Chainable builder that generates Gatsby pages with pagination, utilizing Gatsby's createPage.
 *
 * @private
 * @param {function} createPage - reference to Gatsby's createPage method
 * @param {Array.<Object>} edges - collection of data nodes
 * @param {string} component - the resolved path of the component for each page
 *
 * @throws {Error} Argument `createPage` must be provided.
 * @throws {Error} Argument `edges` must be provided.
 * @throws {Error} Argument `component` must be provided.
 *
 * @see gatsby-pagination.createPaginationPages
 * [Gatsby's createPage documentation]{@link https://www.gatsbyjs.org/docs/bound-action-creators/#createPage}
 */

var PaginationPageBuilder = function () {
  function PaginationPageBuilder(createPage, edges, component) {
    _classCallCheck(this, PaginationPageBuilder);

    if (!createPage) throw Error("Argument `createPage` must be provided.");
    if (!edges) throw Error("Argument `edges` must be provided.");
    if (!component) throw Error("Argument `component` must be provided.");

    this.createPage = createPage;
    this.edges = edges;
    this.component = component;
    this.limit = _constants2.default.DEFAULT_LIMIT;
    this.pathFormatter = _constants2.default.DEFAULT_PATH_FORMATTER;
    this.context = {};

    this.setLimit = this.setLimit.bind(this);
    this.setPathFormatter = this.setPathFormatter.bind(this);
    this.setContext = this.setContext.bind(this);
    this.build = this.build.bind(this);
  }

  /**
   * Set a custom limit.
   * @param {number} value - the limit of nodes per page
   * @returns {Object} - object instance to be chainable
   */


  _createClass(PaginationPageBuilder, [{
    key: "setLimit",
    value: function setLimit(value) {
      this.limit = value;
      return this;
    }

    /**
     * Set a custom path formatter, path formatters are function which take a
     * pageNumber and return the path which Gatsby should use for given page.
     *
     * @param {function(pageNumber): path} formatter - the method used to format path for pages
     * @returns {Object} - object instance to be chainable
     */

  }, {
    key: "setPathFormatter",
    value: function setPathFormatter(formatter) {
      this.pathFormatter = formatter;
      return this;
    }

    /**
     * Set a context object
     * @param {Object} context - the context data to pass to pageCreate, See [Gatsby documentation]@link{https://www.gatsbyjs.org/docs/bound-action-creators/#createPage}
     * @returns {Object} - object instance to be chainable
     */

  }, {
    key: "setContext",
    value: function setContext(context) {
      this.context = context;
      return this;
    }

    /**
     * start build process to create pages with pagination.
     */

  }, {
    key: "build",
    value: function build() {
      var _this = this;

      createEdgeSubsets(this.edges, this.limit).forEach(function (subset, index, subsets) {
        var pageNumber = index + 1;
        var context = JSON.parse(JSON.stringify(_this.context));
        context.nodes = subset;
        context.page = pageNumber;
        context.pages = subsets.length;
        context.total = _this.edges.length;
        context.limit = _this.limit;

        if (hasPrevPage(index)) {
          context.prev = _this.pathFormatter(pageNumber - 1);
        }

        if (hasNextPage(index, subsets)) {
          context.next = _this.pathFormatter(pageNumber + 1);
        }

        return _this.createPage({
          path: _this.pathFormatter(pageNumber),
          component: _this.component,
          context: context
        });
      });
    }
  }]);

  return PaginationPageBuilder;
}();

exports.default = PaginationPageBuilder;